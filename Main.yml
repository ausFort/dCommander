dCommander_Initialise_Main:
  type: world
  debug: false
  events:
    on server start:
    - if <server.has_file[/dCommander/config.yml].not> {
      - inject locally initialise_config
      - announce to_console format:dCommander_Format "Generated new configuration."
    }
    else {
      - yaml load:/dCommander/config.yml fix_formatting id:dCommander_Config
    }
    - run s@dCommander_Players_Save instantly
    - if <server.list_scripts.parse[name].contains[dCommander_Command_Warp]> {
      - run s@dCommander_Warps_Save instantly
    }
    - announce to_console format:dCommander_Format "dCommander successfully loaded."
    on shutdown:
    - if <yaml.list.contains[dCommander_Config]> {
      - yaml savefile:/dCommander/config.yml id:dCommander_Config
    }
    - if <yaml.list.contains[dCommander_Warps]> {
      - yaml savefile:/dCommander/warps.yml id:dCommander_Warps
    }

  initialise_config:
  - yaml create id:dCommander_Config
  - yaml set colors.primary:&f id:dCommander_Config
  - yaml set colors.secondary:&6 id:dCommander_Config
  - yaml set "warps.per_warp_permissions:false" id:dCommander_Config
  - yaml set warps.delay.enabled:false id:dCommander_Config
  - yaml set warps.delay.amount:3 id:dCommander_Config
  - yaml set homes.limit.default:1 id:dCommander_Config
  - yaml set homes.limit.premium:3 id:dCommander_Config
  - yaml set "give.per_item_permissions:false" id:dCommander_Config
  - yaml set "back.limit:5" id:dCommander_Config
  - yaml savefile:/dCommander/config.yml id:dCommander_Config

dCommander_Initialise_Players:
  type: world
  debug: false
  events:
    on player join:
    - if <server.has_file[/dCommander/saves/<player.uuid>.yml].not> {
      - yaml create id:dCommander_<player.uuid>
    }
    else if <yaml.list.contains[dCommander_<player.uuid>].not> {
      - yaml load:/dCommander/saves/<player.uuid>.yml id:dCommander_<player.uuid>
    }
    - define IP <player.ip.address.after[/].before[:]>
    - if <yaml[dCommander_<player.uuid>].read[seen.ips].contains[<def[IP]>].not||true> {
      - yaml set seen.ips:->:<def[IP]> id:dCommander_<player.uuid>
    }
    - define Name <player.name>
    - if <yaml[dCommander_<player.uuid>].read[seen.names].contains[<def[Name]>].not||true> {
      - yaml set seen.names:->:<def[Name]> id:dCommander_<player.uuid>
    }

dCommander_Players_Save:
  type: task
  debug: false
  script:
  - foreach <server.list_players> {
    - if <server.has_file[/dCommander/saves/<def[Value].uuid>].not> {
      - yaml create id:dCommander_<def[Value].uuid>
    }
    else if <yaml.list.contains[dcommander_<def[Value].uuid>].not> {
      - yaml load:/dCommander/saves/<def[Value].uuid>.yml id:dCommander_<def[Value].uuid>
    }
    - yaml savefile:/dCommander/saves/<def[Value].uuid>.yml id:dCommander_<def[Value].uuid>
  }
  - run <script> delay:15s instantly

dCommander_Warps_Save:
  type: task
  debug: false
  script:
  - if <server.has_file[/dCommander/warps.yml].not> {
    - yaml create id:dCommander_Warps
    - yaml savefile:/dCommander/warps.yml id:dCommander_Warps
    - announce to_console format:dCommander_Format "Generated new warps file."
  }
  else if <yaml.list.contains[dCommander_Warps].not> {
    - yaml load:/dCommander/warps.yml fix_formatting id:dCommander_Warps
    - announce to_console format:dCommander_Format "Loaded warps file."
  }
  - run <script> delay:15s

dCommander_Command_dCommander:
  type: command
  debug: false
  name: dcommander
  aliases:
  - dc
  - dcomm
  usage: /dCommander
  allowed help:
  - determine <player.has_permission[<script.yaml_key[permission]>]||<context.server>>
  description: dCommander
  script:
  - choose <context.args.get[1]||help>:
    ## Reload ##
    - case reload:
      - if <player.has_permission[dcommander.command.reload]||<context.server>> {
        - if <server.has_file[/dCommander/config.yml].not> {
          - inject s@dCommander_Initialise_Main path:initialise_config
          - narrate format:dCommander_Format "Config not found, regenerating!"
        }
        else {
          - yaml load:/dCommander/config.yml id:dCommander_Config
        }
        - narrate format:dCommander_Format "Reloaded dCommander!"
        - queue clear
      }
      - narrate format:dCommander_Format "Usage: <proc[dCPS]>/dCommander <&lt>info<&gt>"

    ## Information ##
    - case info:
      - narrate format:dCommander_Format "dCommander Version <proc[dCPS]>0.7<proc[dCPP]>. Made by <proc[dCPS]>Fortifier<proc[dCPP]>."

    ## Help ##
    - default:
      - if <player.has_permission[dcommander.command.reload]||<context.server>> {
        - narrate format:dCommander_Format "Usage: <proc[dCPS]>/dCommander <&lt>info/reload<&gt>"
      }
      else {
        - narrate format:dCommander_Format "Usage: <proc[dCPS]>/dCommander <&lt>info<&gt>"
      }

dCommander_Format:
  type: format
  debug: false
  format: <proc[dPC].context[&7[<proc[dCPS]>dCommander&7]<proc[dCPP]> <text>]>

dCommander_Col_Format:
  type: format
  debug: false
  format: <proc[dPC].context[<text>]>

dPC:
  type: procedure
  debug: false
  script:
  - determine <def[1].parse_color>

dCPP:
  type: procedure
  debug: false
  script:
  - determine <yaml[dCommander_Config].read[Colors.Primary]>

dCPS:
  type: procedure
  debug: false
  script:
  - determine <yaml[dCommander_Config].read[Colors.Secondary]>

dCFL:
  type: procedure
  debug: false
  definitions: dLoc|Simple|Colored|With_World
  script:
  - if <li@true|false.contains[<def[Colored]||null>].not> {
    - define Colored false
  }
  - if <li@true|false.contains[<def[With_World]||null>].not> {
    - define With_World true
  }
  - if <def[Simple]> {
    - define X "<t[<def[Colored]>]:<proc[dCPS]><def[dLoc].x.round><proc[dCPP]>||<def[dLoc].x.round>>"
    - define Y "<t[<def[Colored]>]:<proc[dCPS]><def[dLoc].y.round><proc[dCPP]>||<def[dLoc].y.round>>"
    - define Z "<t[<def[Colored]>]:<proc[dCPS]><def[dLoc].z.round><proc[dCPP]>||<def[dLoc].z.round>>"
  }
  else {
    - define X "<t[<def[Colored]>]:<proc[dCPS]><def[dLoc].x><proc[dCPP]>||<def[dLoc].x>>"
    - define Y "<t[<def[Colored]>]:<proc[dCPS]><def[dLoc].y><proc[dCPP]>||<def[dLoc].y>>"
    - define Z "<t[<def[Colored]>]:<proc[dCPS]><def[dLoc].z><proc[dCPP]>||<def[dLoc].z>>"
  }
  - define World ""
  - if <def[With_World]> {
    - define World ", <t[<def[Colored]>]:<proc[dCPS]><def[dLoc].world.name>||<def[dLoc].world.name>>"
  }
  - define dLoc "<def[X]>, <def[Y]>, <def[Z]><def[World]><&r>"
  - determine <def[dLoc].parse_color>

dCommander_Require_Ingame_Handler:
  type: task
  debug: false
  script:
  - if <context.server> {
    - narrate format:dCommander_Format "You must be ingame to use this command!"
    - queue clear
  }

dCommander_Require_Player_Handler:
  type: task
  debug: false
  script:
  - if <context.server> {
    - narrate format:dCommander_Format "You must specify a player when in console!"
    - queue clear
  }
